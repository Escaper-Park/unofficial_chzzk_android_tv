// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'clip.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

NaverClip _$NaverClipFromJson(Map<String, dynamic> json) {
  return _NaverClip.fromJson(json);
}

/// @nodoc
mixin _$NaverClip {
  String get clipUID => throw _privateConstructorUsedError;
  String? get videoId => throw _privateConstructorUsedError;
  String get clipTitle => throw _privateConstructorUsedError;
  String get ownerChannelId => throw _privateConstructorUsedError;
  String? get thumbnailImageUrl => throw _privateConstructorUsedError;
  String? get categoryType => throw _privateConstructorUsedError;
  String? get clipCategory => throw _privateConstructorUsedError;
  int get duration => throw _privateConstructorUsedError;
  bool get adult => throw _privateConstructorUsedError;
  String get createdDate => throw _privateConstructorUsedError;
  String get recId =>
      throw _privateConstructorUsedError; // required Object? blindType,
  bool? get privateUserBlock => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NaverClipCopyWith<NaverClip> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NaverClipCopyWith<$Res> {
  factory $NaverClipCopyWith(NaverClip value, $Res Function(NaverClip) then) =
      _$NaverClipCopyWithImpl<$Res, NaverClip>;
  @useResult
  $Res call(
      {String clipUID,
      String? videoId,
      String clipTitle,
      String ownerChannelId,
      String? thumbnailImageUrl,
      String? categoryType,
      String? clipCategory,
      int duration,
      bool adult,
      String createdDate,
      String recId,
      bool? privateUserBlock});
}

/// @nodoc
class _$NaverClipCopyWithImpl<$Res, $Val extends NaverClip>
    implements $NaverClipCopyWith<$Res> {
  _$NaverClipCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clipUID = null,
    Object? videoId = freezed,
    Object? clipTitle = null,
    Object? ownerChannelId = null,
    Object? thumbnailImageUrl = freezed,
    Object? categoryType = freezed,
    Object? clipCategory = freezed,
    Object? duration = null,
    Object? adult = null,
    Object? createdDate = null,
    Object? recId = null,
    Object? privateUserBlock = freezed,
  }) {
    return _then(_value.copyWith(
      clipUID: null == clipUID
          ? _value.clipUID
          : clipUID // ignore: cast_nullable_to_non_nullable
              as String,
      videoId: freezed == videoId
          ? _value.videoId
          : videoId // ignore: cast_nullable_to_non_nullable
              as String?,
      clipTitle: null == clipTitle
          ? _value.clipTitle
          : clipTitle // ignore: cast_nullable_to_non_nullable
              as String,
      ownerChannelId: null == ownerChannelId
          ? _value.ownerChannelId
          : ownerChannelId // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailImageUrl: freezed == thumbnailImageUrl
          ? _value.thumbnailImageUrl
          : thumbnailImageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      categoryType: freezed == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String?,
      clipCategory: freezed == clipCategory
          ? _value.clipCategory
          : clipCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as int,
      adult: null == adult
          ? _value.adult
          : adult // ignore: cast_nullable_to_non_nullable
              as bool,
      createdDate: null == createdDate
          ? _value.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as String,
      recId: null == recId
          ? _value.recId
          : recId // ignore: cast_nullable_to_non_nullable
              as String,
      privateUserBlock: freezed == privateUserBlock
          ? _value.privateUserBlock
          : privateUserBlock // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NaverClipImplCopyWith<$Res>
    implements $NaverClipCopyWith<$Res> {
  factory _$$NaverClipImplCopyWith(
          _$NaverClipImpl value, $Res Function(_$NaverClipImpl) then) =
      __$$NaverClipImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String clipUID,
      String? videoId,
      String clipTitle,
      String ownerChannelId,
      String? thumbnailImageUrl,
      String? categoryType,
      String? clipCategory,
      int duration,
      bool adult,
      String createdDate,
      String recId,
      bool? privateUserBlock});
}

/// @nodoc
class __$$NaverClipImplCopyWithImpl<$Res>
    extends _$NaverClipCopyWithImpl<$Res, _$NaverClipImpl>
    implements _$$NaverClipImplCopyWith<$Res> {
  __$$NaverClipImplCopyWithImpl(
      _$NaverClipImpl _value, $Res Function(_$NaverClipImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clipUID = null,
    Object? videoId = freezed,
    Object? clipTitle = null,
    Object? ownerChannelId = null,
    Object? thumbnailImageUrl = freezed,
    Object? categoryType = freezed,
    Object? clipCategory = freezed,
    Object? duration = null,
    Object? adult = null,
    Object? createdDate = null,
    Object? recId = null,
    Object? privateUserBlock = freezed,
  }) {
    return _then(_$NaverClipImpl(
      clipUID: null == clipUID
          ? _value.clipUID
          : clipUID // ignore: cast_nullable_to_non_nullable
              as String,
      videoId: freezed == videoId
          ? _value.videoId
          : videoId // ignore: cast_nullable_to_non_nullable
              as String?,
      clipTitle: null == clipTitle
          ? _value.clipTitle
          : clipTitle // ignore: cast_nullable_to_non_nullable
              as String,
      ownerChannelId: null == ownerChannelId
          ? _value.ownerChannelId
          : ownerChannelId // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailImageUrl: freezed == thumbnailImageUrl
          ? _value.thumbnailImageUrl
          : thumbnailImageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      categoryType: freezed == categoryType
          ? _value.categoryType
          : categoryType // ignore: cast_nullable_to_non_nullable
              as String?,
      clipCategory: freezed == clipCategory
          ? _value.clipCategory
          : clipCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as int,
      adult: null == adult
          ? _value.adult
          : adult // ignore: cast_nullable_to_non_nullable
              as bool,
      createdDate: null == createdDate
          ? _value.createdDate
          : createdDate // ignore: cast_nullable_to_non_nullable
              as String,
      recId: null == recId
          ? _value.recId
          : recId // ignore: cast_nullable_to_non_nullable
              as String,
      privateUserBlock: freezed == privateUserBlock
          ? _value.privateUserBlock
          : privateUserBlock // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NaverClipImpl with DiagnosticableTreeMixin implements _NaverClip {
  const _$NaverClipImpl(
      {required this.clipUID,
      required this.videoId,
      required this.clipTitle,
      required this.ownerChannelId,
      required this.thumbnailImageUrl,
      required this.categoryType,
      required this.clipCategory,
      required this.duration,
      required this.adult,
      required this.createdDate,
      required this.recId,
      required this.privateUserBlock});

  factory _$NaverClipImpl.fromJson(Map<String, dynamic> json) =>
      _$$NaverClipImplFromJson(json);

  @override
  final String clipUID;
  @override
  final String? videoId;
  @override
  final String clipTitle;
  @override
  final String ownerChannelId;
  @override
  final String? thumbnailImageUrl;
  @override
  final String? categoryType;
  @override
  final String? clipCategory;
  @override
  final int duration;
  @override
  final bool adult;
  @override
  final String createdDate;
  @override
  final String recId;
// required Object? blindType,
  @override
  final bool? privateUserBlock;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NaverClip(clipUID: $clipUID, videoId: $videoId, clipTitle: $clipTitle, ownerChannelId: $ownerChannelId, thumbnailImageUrl: $thumbnailImageUrl, categoryType: $categoryType, clipCategory: $clipCategory, duration: $duration, adult: $adult, createdDate: $createdDate, recId: $recId, privateUserBlock: $privateUserBlock)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'NaverClip'))
      ..add(DiagnosticsProperty('clipUID', clipUID))
      ..add(DiagnosticsProperty('videoId', videoId))
      ..add(DiagnosticsProperty('clipTitle', clipTitle))
      ..add(DiagnosticsProperty('ownerChannelId', ownerChannelId))
      ..add(DiagnosticsProperty('thumbnailImageUrl', thumbnailImageUrl))
      ..add(DiagnosticsProperty('categoryType', categoryType))
      ..add(DiagnosticsProperty('clipCategory', clipCategory))
      ..add(DiagnosticsProperty('duration', duration))
      ..add(DiagnosticsProperty('adult', adult))
      ..add(DiagnosticsProperty('createdDate', createdDate))
      ..add(DiagnosticsProperty('recId', recId))
      ..add(DiagnosticsProperty('privateUserBlock', privateUserBlock));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NaverClipImpl &&
            (identical(other.clipUID, clipUID) || other.clipUID == clipUID) &&
            (identical(other.videoId, videoId) || other.videoId == videoId) &&
            (identical(other.clipTitle, clipTitle) ||
                other.clipTitle == clipTitle) &&
            (identical(other.ownerChannelId, ownerChannelId) ||
                other.ownerChannelId == ownerChannelId) &&
            (identical(other.thumbnailImageUrl, thumbnailImageUrl) ||
                other.thumbnailImageUrl == thumbnailImageUrl) &&
            (identical(other.categoryType, categoryType) ||
                other.categoryType == categoryType) &&
            (identical(other.clipCategory, clipCategory) ||
                other.clipCategory == clipCategory) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.adult, adult) || other.adult == adult) &&
            (identical(other.createdDate, createdDate) ||
                other.createdDate == createdDate) &&
            (identical(other.recId, recId) || other.recId == recId) &&
            (identical(other.privateUserBlock, privateUserBlock) ||
                other.privateUserBlock == privateUserBlock));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      clipUID,
      videoId,
      clipTitle,
      ownerChannelId,
      thumbnailImageUrl,
      categoryType,
      clipCategory,
      duration,
      adult,
      createdDate,
      recId,
      privateUserBlock);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NaverClipImplCopyWith<_$NaverClipImpl> get copyWith =>
      __$$NaverClipImplCopyWithImpl<_$NaverClipImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NaverClipImplToJson(
      this,
    );
  }
}

abstract class _NaverClip implements NaverClip {
  const factory _NaverClip(
      {required final String clipUID,
      required final String? videoId,
      required final String clipTitle,
      required final String ownerChannelId,
      required final String? thumbnailImageUrl,
      required final String? categoryType,
      required final String? clipCategory,
      required final int duration,
      required final bool adult,
      required final String createdDate,
      required final String recId,
      required final bool? privateUserBlock}) = _$NaverClipImpl;

  factory _NaverClip.fromJson(Map<String, dynamic> json) =
      _$NaverClipImpl.fromJson;

  @override
  String get clipUID;
  @override
  String? get videoId;
  @override
  String get clipTitle;
  @override
  String get ownerChannelId;
  @override
  String? get thumbnailImageUrl;
  @override
  String? get categoryType;
  @override
  String? get clipCategory;
  @override
  int get duration;
  @override
  bool get adult;
  @override
  String get createdDate;
  @override
  String get recId;
  @override // required Object? blindType,
  bool? get privateUserBlock;
  @override
  @JsonKey(ignore: true)
  _$$NaverClipImplCopyWith<_$NaverClipImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ClipResponse _$ClipResponseFromJson(Map<String, dynamic> json) {
  return _ClipResponse.fromJson(json);
}

/// @nodoc
mixin _$ClipResponse {
  int? get size => throw _privateConstructorUsedError;
  @JsonKey(name: 'page', fromJson: _clipPageFromJson)
  ClipPage? get next => throw _privateConstructorUsedError;
  List<NaverClip> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClipResponseCopyWith<ClipResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClipResponseCopyWith<$Res> {
  factory $ClipResponseCopyWith(
          ClipResponse value, $Res Function(ClipResponse) then) =
      _$ClipResponseCopyWithImpl<$Res, ClipResponse>;
  @useResult
  $Res call(
      {int? size,
      @JsonKey(name: 'page', fromJson: _clipPageFromJson) ClipPage? next,
      List<NaverClip> data});

  $ClipPageCopyWith<$Res>? get next;
}

/// @nodoc
class _$ClipResponseCopyWithImpl<$Res, $Val extends ClipResponse>
    implements $ClipResponseCopyWith<$Res> {
  _$ClipResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? size = freezed,
    Object? next = freezed,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      next: freezed == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as ClipPage?,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<NaverClip>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ClipPageCopyWith<$Res>? get next {
    if (_value.next == null) {
      return null;
    }

    return $ClipPageCopyWith<$Res>(_value.next!, (value) {
      return _then(_value.copyWith(next: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ClipResponseImplCopyWith<$Res>
    implements $ClipResponseCopyWith<$Res> {
  factory _$$ClipResponseImplCopyWith(
          _$ClipResponseImpl value, $Res Function(_$ClipResponseImpl) then) =
      __$$ClipResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? size,
      @JsonKey(name: 'page', fromJson: _clipPageFromJson) ClipPage? next,
      List<NaverClip> data});

  @override
  $ClipPageCopyWith<$Res>? get next;
}

/// @nodoc
class __$$ClipResponseImplCopyWithImpl<$Res>
    extends _$ClipResponseCopyWithImpl<$Res, _$ClipResponseImpl>
    implements _$$ClipResponseImplCopyWith<$Res> {
  __$$ClipResponseImplCopyWithImpl(
      _$ClipResponseImpl _value, $Res Function(_$ClipResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? size = freezed,
    Object? next = freezed,
    Object? data = null,
  }) {
    return _then(_$ClipResponseImpl(
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      next: freezed == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as ClipPage?,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<NaverClip>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ClipResponseImpl with DiagnosticableTreeMixin implements _ClipResponse {
  const _$ClipResponseImpl(
      {required this.size,
      @JsonKey(name: 'page', fromJson: _clipPageFromJson) required this.next,
      required final List<NaverClip> data})
      : _data = data;

  factory _$ClipResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ClipResponseImplFromJson(json);

  @override
  final int? size;
  @override
  @JsonKey(name: 'page', fromJson: _clipPageFromJson)
  final ClipPage? next;
  final List<NaverClip> _data;
  @override
  List<NaverClip> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClipResponse(size: $size, next: $next, data: $data)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClipResponse'))
      ..add(DiagnosticsProperty('size', size))
      ..add(DiagnosticsProperty('next', next))
      ..add(DiagnosticsProperty('data', data));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClipResponseImpl &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.next, next) || other.next == next) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, size, next, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClipResponseImplCopyWith<_$ClipResponseImpl> get copyWith =>
      __$$ClipResponseImplCopyWithImpl<_$ClipResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ClipResponseImplToJson(
      this,
    );
  }
}

abstract class _ClipResponse implements ClipResponse {
  const factory _ClipResponse(
      {required final int? size,
      @JsonKey(name: 'page', fromJson: _clipPageFromJson)
      required final ClipPage? next,
      required final List<NaverClip> data}) = _$ClipResponseImpl;

  factory _ClipResponse.fromJson(Map<String, dynamic> json) =
      _$ClipResponseImpl.fromJson;

  @override
  int? get size;
  @override
  @JsonKey(name: 'page', fromJson: _clipPageFromJson)
  ClipPage? get next;
  @override
  List<NaverClip> get data;
  @override
  @JsonKey(ignore: true)
  _$$ClipResponseImplCopyWith<_$ClipResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ClipPage _$ClipPageFromJson(Map<String, dynamic> json) {
  return _ClipPage.fromJson(json);
}

/// @nodoc
mixin _$ClipPage {
  String? get clipUID => throw _privateConstructorUsedError;
  int? get readCount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClipPageCopyWith<ClipPage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClipPageCopyWith<$Res> {
  factory $ClipPageCopyWith(ClipPage value, $Res Function(ClipPage) then) =
      _$ClipPageCopyWithImpl<$Res, ClipPage>;
  @useResult
  $Res call({String? clipUID, int? readCount});
}

/// @nodoc
class _$ClipPageCopyWithImpl<$Res, $Val extends ClipPage>
    implements $ClipPageCopyWith<$Res> {
  _$ClipPageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clipUID = freezed,
    Object? readCount = freezed,
  }) {
    return _then(_value.copyWith(
      clipUID: freezed == clipUID
          ? _value.clipUID
          : clipUID // ignore: cast_nullable_to_non_nullable
              as String?,
      readCount: freezed == readCount
          ? _value.readCount
          : readCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ClipPageImplCopyWith<$Res>
    implements $ClipPageCopyWith<$Res> {
  factory _$$ClipPageImplCopyWith(
          _$ClipPageImpl value, $Res Function(_$ClipPageImpl) then) =
      __$$ClipPageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? clipUID, int? readCount});
}

/// @nodoc
class __$$ClipPageImplCopyWithImpl<$Res>
    extends _$ClipPageCopyWithImpl<$Res, _$ClipPageImpl>
    implements _$$ClipPageImplCopyWith<$Res> {
  __$$ClipPageImplCopyWithImpl(
      _$ClipPageImpl _value, $Res Function(_$ClipPageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clipUID = freezed,
    Object? readCount = freezed,
  }) {
    return _then(_$ClipPageImpl(
      clipUID: freezed == clipUID
          ? _value.clipUID
          : clipUID // ignore: cast_nullable_to_non_nullable
              as String?,
      readCount: freezed == readCount
          ? _value.readCount
          : readCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ClipPageImpl with DiagnosticableTreeMixin implements _ClipPage {
  const _$ClipPageImpl({required this.clipUID, required this.readCount});

  factory _$ClipPageImpl.fromJson(Map<String, dynamic> json) =>
      _$$ClipPageImplFromJson(json);

  @override
  final String? clipUID;
  @override
  final int? readCount;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClipPage(clipUID: $clipUID, readCount: $readCount)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClipPage'))
      ..add(DiagnosticsProperty('clipUID', clipUID))
      ..add(DiagnosticsProperty('readCount', readCount));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClipPageImpl &&
            (identical(other.clipUID, clipUID) || other.clipUID == clipUID) &&
            (identical(other.readCount, readCount) ||
                other.readCount == readCount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, clipUID, readCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClipPageImplCopyWith<_$ClipPageImpl> get copyWith =>
      __$$ClipPageImplCopyWithImpl<_$ClipPageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ClipPageImplToJson(
      this,
    );
  }
}

abstract class _ClipPage implements ClipPage {
  const factory _ClipPage(
      {required final String? clipUID,
      required final int? readCount}) = _$ClipPageImpl;

  factory _ClipPage.fromJson(Map<String, dynamic> json) =
      _$ClipPageImpl.fromJson;

  @override
  String? get clipUID;
  @override
  int? get readCount;
  @override
  @JsonKey(ignore: true)
  _$$ClipPageImplCopyWith<_$ClipPageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PopularClipResponse _$PopularClipResponseFromJson(Map<String, dynamic> json) {
  return _PopularClipResponse.fromJson(json);
}

/// @nodoc
mixin _$PopularClipResponse {
  int get size => throw _privateConstructorUsedError;
  @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
  PopularClipPage? get next => throw _privateConstructorUsedError;
  List<NaverClip> get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PopularClipResponseCopyWith<PopularClipResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PopularClipResponseCopyWith<$Res> {
  factory $PopularClipResponseCopyWith(
          PopularClipResponse value, $Res Function(PopularClipResponse) then) =
      _$PopularClipResponseCopyWithImpl<$Res, PopularClipResponse>;
  @useResult
  $Res call(
      {int size,
      @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
      PopularClipPage? next,
      List<NaverClip> data});

  $PopularClipPageCopyWith<$Res>? get next;
}

/// @nodoc
class _$PopularClipResponseCopyWithImpl<$Res, $Val extends PopularClipResponse>
    implements $PopularClipResponseCopyWith<$Res> {
  _$PopularClipResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? size = null,
    Object? next = freezed,
    Object? data = null,
  }) {
    return _then(_value.copyWith(
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      next: freezed == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as PopularClipPage?,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<NaverClip>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PopularClipPageCopyWith<$Res>? get next {
    if (_value.next == null) {
      return null;
    }

    return $PopularClipPageCopyWith<$Res>(_value.next!, (value) {
      return _then(_value.copyWith(next: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PopularClipResponseImplCopyWith<$Res>
    implements $PopularClipResponseCopyWith<$Res> {
  factory _$$PopularClipResponseImplCopyWith(_$PopularClipResponseImpl value,
          $Res Function(_$PopularClipResponseImpl) then) =
      __$$PopularClipResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int size,
      @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
      PopularClipPage? next,
      List<NaverClip> data});

  @override
  $PopularClipPageCopyWith<$Res>? get next;
}

/// @nodoc
class __$$PopularClipResponseImplCopyWithImpl<$Res>
    extends _$PopularClipResponseCopyWithImpl<$Res, _$PopularClipResponseImpl>
    implements _$$PopularClipResponseImplCopyWith<$Res> {
  __$$PopularClipResponseImplCopyWithImpl(_$PopularClipResponseImpl _value,
      $Res Function(_$PopularClipResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? size = null,
    Object? next = freezed,
    Object? data = null,
  }) {
    return _then(_$PopularClipResponseImpl(
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      next: freezed == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as PopularClipPage?,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<NaverClip>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PopularClipResponseImpl
    with DiagnosticableTreeMixin
    implements _PopularClipResponse {
  const _$PopularClipResponseImpl(
      {required this.size,
      @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
      required this.next,
      required final List<NaverClip> data})
      : _data = data;

  factory _$PopularClipResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$PopularClipResponseImplFromJson(json);

  @override
  final int size;
  @override
  @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
  final PopularClipPage? next;
  final List<NaverClip> _data;
  @override
  List<NaverClip> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PopularClipResponse(size: $size, next: $next, data: $data)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PopularClipResponse'))
      ..add(DiagnosticsProperty('size', size))
      ..add(DiagnosticsProperty('next', next))
      ..add(DiagnosticsProperty('data', data));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PopularClipResponseImpl &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.next, next) || other.next == next) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, size, next, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PopularClipResponseImplCopyWith<_$PopularClipResponseImpl> get copyWith =>
      __$$PopularClipResponseImplCopyWithImpl<_$PopularClipResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PopularClipResponseImplToJson(
      this,
    );
  }
}

abstract class _PopularClipResponse implements PopularClipResponse {
  const factory _PopularClipResponse(
      {required final int size,
      @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
      required final PopularClipPage? next,
      required final List<NaverClip> data}) = _$PopularClipResponseImpl;

  factory _PopularClipResponse.fromJson(Map<String, dynamic> json) =
      _$PopularClipResponseImpl.fromJson;

  @override
  int get size;
  @override
  @JsonKey(name: 'page', fromJson: _popularClipPageFromJson)
  PopularClipPage? get next;
  @override
  List<NaverClip> get data;
  @override
  @JsonKey(ignore: true)
  _$$PopularClipResponseImplCopyWith<_$PopularClipResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PopularClipPage _$PopularClipPageFromJson(Map<String, dynamic> json) {
  return _PopularClipPage.fromJson(json);
}

/// @nodoc
mixin _$PopularClipPage {
  String? get next => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PopularClipPageCopyWith<PopularClipPage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PopularClipPageCopyWith<$Res> {
  factory $PopularClipPageCopyWith(
          PopularClipPage value, $Res Function(PopularClipPage) then) =
      _$PopularClipPageCopyWithImpl<$Res, PopularClipPage>;
  @useResult
  $Res call({String? next});
}

/// @nodoc
class _$PopularClipPageCopyWithImpl<$Res, $Val extends PopularClipPage>
    implements $PopularClipPageCopyWith<$Res> {
  _$PopularClipPageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? next = freezed,
  }) {
    return _then(_value.copyWith(
      next: freezed == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PopularClipPageImplCopyWith<$Res>
    implements $PopularClipPageCopyWith<$Res> {
  factory _$$PopularClipPageImplCopyWith(_$PopularClipPageImpl value,
          $Res Function(_$PopularClipPageImpl) then) =
      __$$PopularClipPageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? next});
}

/// @nodoc
class __$$PopularClipPageImplCopyWithImpl<$Res>
    extends _$PopularClipPageCopyWithImpl<$Res, _$PopularClipPageImpl>
    implements _$$PopularClipPageImplCopyWith<$Res> {
  __$$PopularClipPageImplCopyWithImpl(
      _$PopularClipPageImpl _value, $Res Function(_$PopularClipPageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? next = freezed,
  }) {
    return _then(_$PopularClipPageImpl(
      next: freezed == next
          ? _value.next
          : next // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PopularClipPageImpl
    with DiagnosticableTreeMixin
    implements _PopularClipPage {
  const _$PopularClipPageImpl({required this.next});

  factory _$PopularClipPageImpl.fromJson(Map<String, dynamic> json) =>
      _$$PopularClipPageImplFromJson(json);

  @override
  final String? next;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PopularClipPage(next: $next)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PopularClipPage'))
      ..add(DiagnosticsProperty('next', next));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PopularClipPageImpl &&
            (identical(other.next, next) || other.next == next));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, next);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PopularClipPageImplCopyWith<_$PopularClipPageImpl> get copyWith =>
      __$$PopularClipPageImplCopyWithImpl<_$PopularClipPageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PopularClipPageImplToJson(
      this,
    );
  }
}

abstract class _PopularClipPage implements PopularClipPage {
  const factory _PopularClipPage({required final String? next}) =
      _$PopularClipPageImpl;

  factory _PopularClipPage.fromJson(Map<String, dynamic> json) =
      _$PopularClipPageImpl.fromJson;

  @override
  String? get next;
  @override
  @JsonKey(ignore: true)
  _$$PopularClipPageImplCopyWith<_$PopularClipPageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
