// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'live_playback_json.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

LivePlaybackJson _$LivePlaybackJsonFromJson(Map<String, dynamic> json) {
  return _LivePlaybackJson.fromJson(json);
}

/// @nodoc
mixin _$LivePlaybackJson {
  Meta get meta => throw _privateConstructorUsedError;
  ServiceMeta get serviceMeta => throw _privateConstructorUsedError;
  Live get live => throw _privateConstructorUsedError;
  List<Map<String, String>> get api => throw _privateConstructorUsedError;
  List<Media> get media => throw _privateConstructorUsedError;
  Thumbnail get thumbnail => throw _privateConstructorUsedError;
  List<Object?> get multiview => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LivePlaybackJsonCopyWith<LivePlaybackJson> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LivePlaybackJsonCopyWith<$Res> {
  factory $LivePlaybackJsonCopyWith(
          LivePlaybackJson value, $Res Function(LivePlaybackJson) then) =
      _$LivePlaybackJsonCopyWithImpl<$Res, LivePlaybackJson>;
  @useResult
  $Res call(
      {Meta meta,
      ServiceMeta serviceMeta,
      Live live,
      List<Map<String, String>> api,
      List<Media> media,
      Thumbnail thumbnail,
      List<Object?> multiview});

  $MetaCopyWith<$Res> get meta;
  $ServiceMetaCopyWith<$Res> get serviceMeta;
  $LiveCopyWith<$Res> get live;
  $ThumbnailCopyWith<$Res> get thumbnail;
}

/// @nodoc
class _$LivePlaybackJsonCopyWithImpl<$Res, $Val extends LivePlaybackJson>
    implements $LivePlaybackJsonCopyWith<$Res> {
  _$LivePlaybackJsonCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? meta = null,
    Object? serviceMeta = null,
    Object? live = null,
    Object? api = null,
    Object? media = null,
    Object? thumbnail = null,
    Object? multiview = null,
  }) {
    return _then(_value.copyWith(
      meta: null == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta,
      serviceMeta: null == serviceMeta
          ? _value.serviceMeta
          : serviceMeta // ignore: cast_nullable_to_non_nullable
              as ServiceMeta,
      live: null == live
          ? _value.live
          : live // ignore: cast_nullable_to_non_nullable
              as Live,
      api: null == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as List<Map<String, String>>,
      media: null == media
          ? _value.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<Media>,
      thumbnail: null == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as Thumbnail,
      multiview: null == multiview
          ? _value.multiview
          : multiview // ignore: cast_nullable_to_non_nullable
              as List<Object?>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res> get meta {
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ServiceMetaCopyWith<$Res> get serviceMeta {
    return $ServiceMetaCopyWith<$Res>(_value.serviceMeta, (value) {
      return _then(_value.copyWith(serviceMeta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $LiveCopyWith<$Res> get live {
    return $LiveCopyWith<$Res>(_value.live, (value) {
      return _then(_value.copyWith(live: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ThumbnailCopyWith<$Res> get thumbnail {
    return $ThumbnailCopyWith<$Res>(_value.thumbnail, (value) {
      return _then(_value.copyWith(thumbnail: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LivePlaybackJsonImplCopyWith<$Res>
    implements $LivePlaybackJsonCopyWith<$Res> {
  factory _$$LivePlaybackJsonImplCopyWith(_$LivePlaybackJsonImpl value,
          $Res Function(_$LivePlaybackJsonImpl) then) =
      __$$LivePlaybackJsonImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Meta meta,
      ServiceMeta serviceMeta,
      Live live,
      List<Map<String, String>> api,
      List<Media> media,
      Thumbnail thumbnail,
      List<Object?> multiview});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $ServiceMetaCopyWith<$Res> get serviceMeta;
  @override
  $LiveCopyWith<$Res> get live;
  @override
  $ThumbnailCopyWith<$Res> get thumbnail;
}

/// @nodoc
class __$$LivePlaybackJsonImplCopyWithImpl<$Res>
    extends _$LivePlaybackJsonCopyWithImpl<$Res, _$LivePlaybackJsonImpl>
    implements _$$LivePlaybackJsonImplCopyWith<$Res> {
  __$$LivePlaybackJsonImplCopyWithImpl(_$LivePlaybackJsonImpl _value,
      $Res Function(_$LivePlaybackJsonImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? meta = null,
    Object? serviceMeta = null,
    Object? live = null,
    Object? api = null,
    Object? media = null,
    Object? thumbnail = null,
    Object? multiview = null,
  }) {
    return _then(_$LivePlaybackJsonImpl(
      meta: null == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta,
      serviceMeta: null == serviceMeta
          ? _value.serviceMeta
          : serviceMeta // ignore: cast_nullable_to_non_nullable
              as ServiceMeta,
      live: null == live
          ? _value.live
          : live // ignore: cast_nullable_to_non_nullable
              as Live,
      api: null == api
          ? _value._api
          : api // ignore: cast_nullable_to_non_nullable
              as List<Map<String, String>>,
      media: null == media
          ? _value._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<Media>,
      thumbnail: null == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as Thumbnail,
      multiview: null == multiview
          ? _value._multiview
          : multiview // ignore: cast_nullable_to_non_nullable
              as List<Object?>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LivePlaybackJsonImpl implements _LivePlaybackJson {
  const _$LivePlaybackJsonImpl(
      {required this.meta,
      required this.serviceMeta,
      required this.live,
      required final List<Map<String, String>> api,
      required final List<Media> media,
      required this.thumbnail,
      required final List<Object?> multiview})
      : _api = api,
        _media = media,
        _multiview = multiview;

  factory _$LivePlaybackJsonImpl.fromJson(Map<String, dynamic> json) =>
      _$$LivePlaybackJsonImplFromJson(json);

  @override
  final Meta meta;
  @override
  final ServiceMeta serviceMeta;
  @override
  final Live live;
  final List<Map<String, String>> _api;
  @override
  List<Map<String, String>> get api {
    if (_api is EqualUnmodifiableListView) return _api;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_api);
  }

  final List<Media> _media;
  @override
  List<Media> get media {
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_media);
  }

  @override
  final Thumbnail thumbnail;
  final List<Object?> _multiview;
  @override
  List<Object?> get multiview {
    if (_multiview is EqualUnmodifiableListView) return _multiview;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_multiview);
  }

  @override
  String toString() {
    return 'LivePlaybackJson(meta: $meta, serviceMeta: $serviceMeta, live: $live, api: $api, media: $media, thumbnail: $thumbnail, multiview: $multiview)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LivePlaybackJsonImpl &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.serviceMeta, serviceMeta) ||
                other.serviceMeta == serviceMeta) &&
            (identical(other.live, live) || other.live == live) &&
            const DeepCollectionEquality().equals(other._api, _api) &&
            const DeepCollectionEquality().equals(other._media, _media) &&
            (identical(other.thumbnail, thumbnail) ||
                other.thumbnail == thumbnail) &&
            const DeepCollectionEquality()
                .equals(other._multiview, _multiview));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      meta,
      serviceMeta,
      live,
      const DeepCollectionEquality().hash(_api),
      const DeepCollectionEquality().hash(_media),
      thumbnail,
      const DeepCollectionEquality().hash(_multiview));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LivePlaybackJsonImplCopyWith<_$LivePlaybackJsonImpl> get copyWith =>
      __$$LivePlaybackJsonImplCopyWithImpl<_$LivePlaybackJsonImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LivePlaybackJsonImplToJson(
      this,
    );
  }
}

abstract class _LivePlaybackJson implements LivePlaybackJson {
  const factory _LivePlaybackJson(
      {required final Meta meta,
      required final ServiceMeta serviceMeta,
      required final Live live,
      required final List<Map<String, String>> api,
      required final List<Media> media,
      required final Thumbnail thumbnail,
      required final List<Object?> multiview}) = _$LivePlaybackJsonImpl;

  factory _LivePlaybackJson.fromJson(Map<String, dynamic> json) =
      _$LivePlaybackJsonImpl.fromJson;

  @override
  Meta get meta;
  @override
  ServiceMeta get serviceMeta;
  @override
  Live get live;
  @override
  List<Map<String, String>> get api;
  @override
  List<Media> get media;
  @override
  Thumbnail get thumbnail;
  @override
  List<Object?> get multiview;
  @override
  @JsonKey(ignore: true)
  _$$LivePlaybackJsonImplCopyWith<_$LivePlaybackJsonImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Meta _$MetaFromJson(Map<String, dynamic> json) {
  return _Meta.fromJson(json);
}

/// @nodoc
mixin _$Meta {
  String get videoId => throw _privateConstructorUsedError;
  int get streamSeq => throw _privateConstructorUsedError;
  String get liveId => throw _privateConstructorUsedError;
  bool get paidLive => throw _privateConstructorUsedError;
  CdnInfo get cdnInfo =>
      throw _privateConstructorUsedError; // Nullable for abroad users
  bool? get p2p => throw _privateConstructorUsedError;
  bool get cmcdEnabled => throw _privateConstructorUsedError; /* For Vod */
  bool? get liveRewind => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MetaCopyWith<Meta> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetaCopyWith<$Res> {
  factory $MetaCopyWith(Meta value, $Res Function(Meta) then) =
      _$MetaCopyWithImpl<$Res, Meta>;
  @useResult
  $Res call(
      {String videoId,
      int streamSeq,
      String liveId,
      bool paidLive,
      CdnInfo cdnInfo,
      bool? p2p,
      bool cmcdEnabled,
      bool? liveRewind});

  $CdnInfoCopyWith<$Res> get cdnInfo;
}

/// @nodoc
class _$MetaCopyWithImpl<$Res, $Val extends Meta>
    implements $MetaCopyWith<$Res> {
  _$MetaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? videoId = null,
    Object? streamSeq = null,
    Object? liveId = null,
    Object? paidLive = null,
    Object? cdnInfo = null,
    Object? p2p = freezed,
    Object? cmcdEnabled = null,
    Object? liveRewind = freezed,
  }) {
    return _then(_value.copyWith(
      videoId: null == videoId
          ? _value.videoId
          : videoId // ignore: cast_nullable_to_non_nullable
              as String,
      streamSeq: null == streamSeq
          ? _value.streamSeq
          : streamSeq // ignore: cast_nullable_to_non_nullable
              as int,
      liveId: null == liveId
          ? _value.liveId
          : liveId // ignore: cast_nullable_to_non_nullable
              as String,
      paidLive: null == paidLive
          ? _value.paidLive
          : paidLive // ignore: cast_nullable_to_non_nullable
              as bool,
      cdnInfo: null == cdnInfo
          ? _value.cdnInfo
          : cdnInfo // ignore: cast_nullable_to_non_nullable
              as CdnInfo,
      p2p: freezed == p2p
          ? _value.p2p
          : p2p // ignore: cast_nullable_to_non_nullable
              as bool?,
      cmcdEnabled: null == cmcdEnabled
          ? _value.cmcdEnabled
          : cmcdEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      liveRewind: freezed == liveRewind
          ? _value.liveRewind
          : liveRewind // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CdnInfoCopyWith<$Res> get cdnInfo {
    return $CdnInfoCopyWith<$Res>(_value.cdnInfo, (value) {
      return _then(_value.copyWith(cdnInfo: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MetaImplCopyWith<$Res> implements $MetaCopyWith<$Res> {
  factory _$$MetaImplCopyWith(
          _$MetaImpl value, $Res Function(_$MetaImpl) then) =
      __$$MetaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String videoId,
      int streamSeq,
      String liveId,
      bool paidLive,
      CdnInfo cdnInfo,
      bool? p2p,
      bool cmcdEnabled,
      bool? liveRewind});

  @override
  $CdnInfoCopyWith<$Res> get cdnInfo;
}

/// @nodoc
class __$$MetaImplCopyWithImpl<$Res>
    extends _$MetaCopyWithImpl<$Res, _$MetaImpl>
    implements _$$MetaImplCopyWith<$Res> {
  __$$MetaImplCopyWithImpl(_$MetaImpl _value, $Res Function(_$MetaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? videoId = null,
    Object? streamSeq = null,
    Object? liveId = null,
    Object? paidLive = null,
    Object? cdnInfo = null,
    Object? p2p = freezed,
    Object? cmcdEnabled = null,
    Object? liveRewind = freezed,
  }) {
    return _then(_$MetaImpl(
      videoId: null == videoId
          ? _value.videoId
          : videoId // ignore: cast_nullable_to_non_nullable
              as String,
      streamSeq: null == streamSeq
          ? _value.streamSeq
          : streamSeq // ignore: cast_nullable_to_non_nullable
              as int,
      liveId: null == liveId
          ? _value.liveId
          : liveId // ignore: cast_nullable_to_non_nullable
              as String,
      paidLive: null == paidLive
          ? _value.paidLive
          : paidLive // ignore: cast_nullable_to_non_nullable
              as bool,
      cdnInfo: null == cdnInfo
          ? _value.cdnInfo
          : cdnInfo // ignore: cast_nullable_to_non_nullable
              as CdnInfo,
      p2p: freezed == p2p
          ? _value.p2p
          : p2p // ignore: cast_nullable_to_non_nullable
              as bool?,
      cmcdEnabled: null == cmcdEnabled
          ? _value.cmcdEnabled
          : cmcdEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      liveRewind: freezed == liveRewind
          ? _value.liveRewind
          : liveRewind // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MetaImpl implements _Meta {
  const _$MetaImpl(
      {required this.videoId,
      required this.streamSeq,
      required this.liveId,
      required this.paidLive,
      required this.cdnInfo,
      required this.p2p,
      required this.cmcdEnabled,
      required this.liveRewind});

  factory _$MetaImpl.fromJson(Map<String, dynamic> json) =>
      _$$MetaImplFromJson(json);

  @override
  final String videoId;
  @override
  final int streamSeq;
  @override
  final String liveId;
  @override
  final bool paidLive;
  @override
  final CdnInfo cdnInfo;
// Nullable for abroad users
  @override
  final bool? p2p;
  @override
  final bool cmcdEnabled;
/* For Vod */
  @override
  final bool? liveRewind;

  @override
  String toString() {
    return 'Meta(videoId: $videoId, streamSeq: $streamSeq, liveId: $liveId, paidLive: $paidLive, cdnInfo: $cdnInfo, p2p: $p2p, cmcdEnabled: $cmcdEnabled, liveRewind: $liveRewind)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MetaImpl &&
            (identical(other.videoId, videoId) || other.videoId == videoId) &&
            (identical(other.streamSeq, streamSeq) ||
                other.streamSeq == streamSeq) &&
            (identical(other.liveId, liveId) || other.liveId == liveId) &&
            (identical(other.paidLive, paidLive) ||
                other.paidLive == paidLive) &&
            (identical(other.cdnInfo, cdnInfo) || other.cdnInfo == cdnInfo) &&
            (identical(other.p2p, p2p) || other.p2p == p2p) &&
            (identical(other.cmcdEnabled, cmcdEnabled) ||
                other.cmcdEnabled == cmcdEnabled) &&
            (identical(other.liveRewind, liveRewind) ||
                other.liveRewind == liveRewind));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, videoId, streamSeq, liveId,
      paidLive, cdnInfo, p2p, cmcdEnabled, liveRewind);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MetaImplCopyWith<_$MetaImpl> get copyWith =>
      __$$MetaImplCopyWithImpl<_$MetaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MetaImplToJson(
      this,
    );
  }
}

abstract class _Meta implements Meta {
  const factory _Meta(
      {required final String videoId,
      required final int streamSeq,
      required final String liveId,
      required final bool paidLive,
      required final CdnInfo cdnInfo,
      required final bool? p2p,
      required final bool cmcdEnabled,
      required final bool? liveRewind}) = _$MetaImpl;

  factory _Meta.fromJson(Map<String, dynamic> json) = _$MetaImpl.fromJson;

  @override
  String get videoId;
  @override
  int get streamSeq;
  @override
  String get liveId;
  @override
  bool get paidLive;
  @override
  CdnInfo get cdnInfo;
  @override // Nullable for abroad users
  bool? get p2p;
  @override
  bool get cmcdEnabled;
  @override /* For Vod */
  bool? get liveRewind;
  @override
  @JsonKey(ignore: true)
  _$$MetaImplCopyWith<_$MetaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CdnInfo _$CdnInfoFromJson(Map<String, dynamic> json) {
  return _CdnInfo.fromJson(json);
}

/// @nodoc
mixin _$CdnInfo {
  String get cdnType => throw _privateConstructorUsedError;
  bool get zeroRating => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CdnInfoCopyWith<CdnInfo> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CdnInfoCopyWith<$Res> {
  factory $CdnInfoCopyWith(CdnInfo value, $Res Function(CdnInfo) then) =
      _$CdnInfoCopyWithImpl<$Res, CdnInfo>;
  @useResult
  $Res call({String cdnType, bool zeroRating});
}

/// @nodoc
class _$CdnInfoCopyWithImpl<$Res, $Val extends CdnInfo>
    implements $CdnInfoCopyWith<$Res> {
  _$CdnInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cdnType = null,
    Object? zeroRating = null,
  }) {
    return _then(_value.copyWith(
      cdnType: null == cdnType
          ? _value.cdnType
          : cdnType // ignore: cast_nullable_to_non_nullable
              as String,
      zeroRating: null == zeroRating
          ? _value.zeroRating
          : zeroRating // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CdnInfoImplCopyWith<$Res> implements $CdnInfoCopyWith<$Res> {
  factory _$$CdnInfoImplCopyWith(
          _$CdnInfoImpl value, $Res Function(_$CdnInfoImpl) then) =
      __$$CdnInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String cdnType, bool zeroRating});
}

/// @nodoc
class __$$CdnInfoImplCopyWithImpl<$Res>
    extends _$CdnInfoCopyWithImpl<$Res, _$CdnInfoImpl>
    implements _$$CdnInfoImplCopyWith<$Res> {
  __$$CdnInfoImplCopyWithImpl(
      _$CdnInfoImpl _value, $Res Function(_$CdnInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cdnType = null,
    Object? zeroRating = null,
  }) {
    return _then(_$CdnInfoImpl(
      cdnType: null == cdnType
          ? _value.cdnType
          : cdnType // ignore: cast_nullable_to_non_nullable
              as String,
      zeroRating: null == zeroRating
          ? _value.zeroRating
          : zeroRating // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CdnInfoImpl implements _CdnInfo {
  const _$CdnInfoImpl({required this.cdnType, required this.zeroRating});

  factory _$CdnInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$CdnInfoImplFromJson(json);

  @override
  final String cdnType;
  @override
  final bool zeroRating;

  @override
  String toString() {
    return 'CdnInfo(cdnType: $cdnType, zeroRating: $zeroRating)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CdnInfoImpl &&
            (identical(other.cdnType, cdnType) || other.cdnType == cdnType) &&
            (identical(other.zeroRating, zeroRating) ||
                other.zeroRating == zeroRating));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, cdnType, zeroRating);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CdnInfoImplCopyWith<_$CdnInfoImpl> get copyWith =>
      __$$CdnInfoImplCopyWithImpl<_$CdnInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CdnInfoImplToJson(
      this,
    );
  }
}

abstract class _CdnInfo implements CdnInfo {
  const factory _CdnInfo(
      {required final String cdnType,
      required final bool zeroRating}) = _$CdnInfoImpl;

  factory _CdnInfo.fromJson(Map<String, dynamic> json) = _$CdnInfoImpl.fromJson;

  @override
  String get cdnType;
  @override
  bool get zeroRating;
  @override
  @JsonKey(ignore: true)
  _$$CdnInfoImplCopyWith<_$CdnInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ServiceMeta _$ServiceMetaFromJson(Map<String, dynamic> json) {
  return _ServiceMeta.fromJson(json);
}

/// @nodoc
mixin _$ServiceMeta {
  String get contentType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ServiceMetaCopyWith<ServiceMeta> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ServiceMetaCopyWith<$Res> {
  factory $ServiceMetaCopyWith(
          ServiceMeta value, $Res Function(ServiceMeta) then) =
      _$ServiceMetaCopyWithImpl<$Res, ServiceMeta>;
  @useResult
  $Res call({String contentType});
}

/// @nodoc
class _$ServiceMetaCopyWithImpl<$Res, $Val extends ServiceMeta>
    implements $ServiceMetaCopyWith<$Res> {
  _$ServiceMetaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contentType = null,
  }) {
    return _then(_value.copyWith(
      contentType: null == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ServiceMetaImplCopyWith<$Res>
    implements $ServiceMetaCopyWith<$Res> {
  factory _$$ServiceMetaImplCopyWith(
          _$ServiceMetaImpl value, $Res Function(_$ServiceMetaImpl) then) =
      __$$ServiceMetaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String contentType});
}

/// @nodoc
class __$$ServiceMetaImplCopyWithImpl<$Res>
    extends _$ServiceMetaCopyWithImpl<$Res, _$ServiceMetaImpl>
    implements _$$ServiceMetaImplCopyWith<$Res> {
  __$$ServiceMetaImplCopyWithImpl(
      _$ServiceMetaImpl _value, $Res Function(_$ServiceMetaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contentType = null,
  }) {
    return _then(_$ServiceMetaImpl(
      contentType: null == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ServiceMetaImpl implements _ServiceMeta {
  const _$ServiceMetaImpl({required this.contentType});

  factory _$ServiceMetaImpl.fromJson(Map<String, dynamic> json) =>
      _$$ServiceMetaImplFromJson(json);

  @override
  final String contentType;

  @override
  String toString() {
    return 'ServiceMeta(contentType: $contentType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ServiceMetaImpl &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, contentType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ServiceMetaImplCopyWith<_$ServiceMetaImpl> get copyWith =>
      __$$ServiceMetaImplCopyWithImpl<_$ServiceMetaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ServiceMetaImplToJson(
      this,
    );
  }
}

abstract class _ServiceMeta implements ServiceMeta {
  const factory _ServiceMeta({required final String contentType}) =
      _$ServiceMetaImpl;

  factory _ServiceMeta.fromJson(Map<String, dynamic> json) =
      _$ServiceMetaImpl.fromJson;

  @override
  String get contentType;
  @override
  @JsonKey(ignore: true)
  _$$ServiceMetaImplCopyWith<_$ServiceMetaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Live _$LiveFromJson(Map<String, dynamic> json) {
  return _Live.fromJson(json);
}

/// @nodoc
mixin _$Live {
  String get start => throw _privateConstructorUsedError;
  String get open => throw _privateConstructorUsedError;
  bool get timeMachine => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LiveCopyWith<Live> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiveCopyWith<$Res> {
  factory $LiveCopyWith(Live value, $Res Function(Live) then) =
      _$LiveCopyWithImpl<$Res, Live>;
  @useResult
  $Res call({String start, String open, bool timeMachine, String status});
}

/// @nodoc
class _$LiveCopyWithImpl<$Res, $Val extends Live>
    implements $LiveCopyWith<$Res> {
  _$LiveCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? start = null,
    Object? open = null,
    Object? timeMachine = null,
    Object? status = null,
  }) {
    return _then(_value.copyWith(
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as String,
      open: null == open
          ? _value.open
          : open // ignore: cast_nullable_to_non_nullable
              as String,
      timeMachine: null == timeMachine
          ? _value.timeMachine
          : timeMachine // ignore: cast_nullable_to_non_nullable
              as bool,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LiveImplCopyWith<$Res> implements $LiveCopyWith<$Res> {
  factory _$$LiveImplCopyWith(
          _$LiveImpl value, $Res Function(_$LiveImpl) then) =
      __$$LiveImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String start, String open, bool timeMachine, String status});
}

/// @nodoc
class __$$LiveImplCopyWithImpl<$Res>
    extends _$LiveCopyWithImpl<$Res, _$LiveImpl>
    implements _$$LiveImplCopyWith<$Res> {
  __$$LiveImplCopyWithImpl(_$LiveImpl _value, $Res Function(_$LiveImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? start = null,
    Object? open = null,
    Object? timeMachine = null,
    Object? status = null,
  }) {
    return _then(_$LiveImpl(
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as String,
      open: null == open
          ? _value.open
          : open // ignore: cast_nullable_to_non_nullable
              as String,
      timeMachine: null == timeMachine
          ? _value.timeMachine
          : timeMachine // ignore: cast_nullable_to_non_nullable
              as bool,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LiveImpl implements _Live {
  const _$LiveImpl(
      {required this.start,
      required this.open,
      required this.timeMachine,
      required this.status});

  factory _$LiveImpl.fromJson(Map<String, dynamic> json) =>
      _$$LiveImplFromJson(json);

  @override
  final String start;
  @override
  final String open;
  @override
  final bool timeMachine;
  @override
  final String status;

  @override
  String toString() {
    return 'Live(start: $start, open: $open, timeMachine: $timeMachine, status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiveImpl &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.open, open) || other.open == open) &&
            (identical(other.timeMachine, timeMachine) ||
                other.timeMachine == timeMachine) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, start, open, timeMachine, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiveImplCopyWith<_$LiveImpl> get copyWith =>
      __$$LiveImplCopyWithImpl<_$LiveImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LiveImplToJson(
      this,
    );
  }
}

abstract class _Live implements Live {
  const factory _Live(
      {required final String start,
      required final String open,
      required final bool timeMachine,
      required final String status}) = _$LiveImpl;

  factory _Live.fromJson(Map<String, dynamic> json) = _$LiveImpl.fromJson;

  @override
  String get start;
  @override
  String get open;
  @override
  bool get timeMachine;
  @override
  String get status;
  @override
  @JsonKey(ignore: true)
  _$$LiveImplCopyWith<_$LiveImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Media _$MediaFromJson(Map<String, dynamic> json) {
  return _Media.fromJson(json);
}

/// @nodoc
mixin _$Media {
  String get mediaId => throw _privateConstructorUsedError;
  String get protocol => throw _privateConstructorUsedError;
  String get path => throw _privateConstructorUsedError;
  String? get latency => throw _privateConstructorUsedError;
  List<EncodingTrack> get encodingTrack => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MediaCopyWith<Media> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MediaCopyWith<$Res> {
  factory $MediaCopyWith(Media value, $Res Function(Media) then) =
      _$MediaCopyWithImpl<$Res, Media>;
  @useResult
  $Res call(
      {String mediaId,
      String protocol,
      String path,
      String? latency,
      List<EncodingTrack> encodingTrack});
}

/// @nodoc
class _$MediaCopyWithImpl<$Res, $Val extends Media>
    implements $MediaCopyWith<$Res> {
  _$MediaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mediaId = null,
    Object? protocol = null,
    Object? path = null,
    Object? latency = freezed,
    Object? encodingTrack = null,
  }) {
    return _then(_value.copyWith(
      mediaId: null == mediaId
          ? _value.mediaId
          : mediaId // ignore: cast_nullable_to_non_nullable
              as String,
      protocol: null == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      latency: freezed == latency
          ? _value.latency
          : latency // ignore: cast_nullable_to_non_nullable
              as String?,
      encodingTrack: null == encodingTrack
          ? _value.encodingTrack
          : encodingTrack // ignore: cast_nullable_to_non_nullable
              as List<EncodingTrack>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MediaImplCopyWith<$Res> implements $MediaCopyWith<$Res> {
  factory _$$MediaImplCopyWith(
          _$MediaImpl value, $Res Function(_$MediaImpl) then) =
      __$$MediaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String mediaId,
      String protocol,
      String path,
      String? latency,
      List<EncodingTrack> encodingTrack});
}

/// @nodoc
class __$$MediaImplCopyWithImpl<$Res>
    extends _$MediaCopyWithImpl<$Res, _$MediaImpl>
    implements _$$MediaImplCopyWith<$Res> {
  __$$MediaImplCopyWithImpl(
      _$MediaImpl _value, $Res Function(_$MediaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mediaId = null,
    Object? protocol = null,
    Object? path = null,
    Object? latency = freezed,
    Object? encodingTrack = null,
  }) {
    return _then(_$MediaImpl(
      mediaId: null == mediaId
          ? _value.mediaId
          : mediaId // ignore: cast_nullable_to_non_nullable
              as String,
      protocol: null == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      latency: freezed == latency
          ? _value.latency
          : latency // ignore: cast_nullable_to_non_nullable
              as String?,
      encodingTrack: null == encodingTrack
          ? _value._encodingTrack
          : encodingTrack // ignore: cast_nullable_to_non_nullable
              as List<EncodingTrack>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MediaImpl implements _Media {
  const _$MediaImpl(
      {required this.mediaId,
      required this.protocol,
      required this.path,
      required this.latency,
      required final List<EncodingTrack> encodingTrack})
      : _encodingTrack = encodingTrack;

  factory _$MediaImpl.fromJson(Map<String, dynamic> json) =>
      _$$MediaImplFromJson(json);

  @override
  final String mediaId;
  @override
  final String protocol;
  @override
  final String path;
  @override
  final String? latency;
  final List<EncodingTrack> _encodingTrack;
  @override
  List<EncodingTrack> get encodingTrack {
    if (_encodingTrack is EqualUnmodifiableListView) return _encodingTrack;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_encodingTrack);
  }

  @override
  String toString() {
    return 'Media(mediaId: $mediaId, protocol: $protocol, path: $path, latency: $latency, encodingTrack: $encodingTrack)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MediaImpl &&
            (identical(other.mediaId, mediaId) || other.mediaId == mediaId) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.latency, latency) || other.latency == latency) &&
            const DeepCollectionEquality()
                .equals(other._encodingTrack, _encodingTrack));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, mediaId, protocol, path, latency,
      const DeepCollectionEquality().hash(_encodingTrack));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MediaImplCopyWith<_$MediaImpl> get copyWith =>
      __$$MediaImplCopyWithImpl<_$MediaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MediaImplToJson(
      this,
    );
  }
}

abstract class _Media implements Media {
  const factory _Media(
      {required final String mediaId,
      required final String protocol,
      required final String path,
      required final String? latency,
      required final List<EncodingTrack> encodingTrack}) = _$MediaImpl;

  factory _Media.fromJson(Map<String, dynamic> json) = _$MediaImpl.fromJson;

  @override
  String get mediaId;
  @override
  String get protocol;
  @override
  String get path;
  @override
  String? get latency;
  @override
  List<EncodingTrack> get encodingTrack;
  @override
  @JsonKey(ignore: true)
  _$$MediaImplCopyWith<_$MediaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EncodingTrack _$EncodingTrackFromJson(Map<String, dynamic> json) {
  return _EncodingTrack.fromJson(json);
}

/// @nodoc
mixin _$EncodingTrack {
  String get encodingTrackId => throw _privateConstructorUsedError;
  String? get videoProfile => throw _privateConstructorUsedError;
  String? get audioProfile => throw _privateConstructorUsedError;
  String? get videoCodec => throw _privateConstructorUsedError;
  int? get videoBitRate => throw _privateConstructorUsedError;
  int get audioBitRate => throw _privateConstructorUsedError;
  String? get videoFrameRate => throw _privateConstructorUsedError;
  int? get videoWidth => throw _privateConstructorUsedError;
  int? get videoHeight => throw _privateConstructorUsedError;
  int get audioSamplingRate => throw _privateConstructorUsedError;
  int get audioChannel => throw _privateConstructorUsedError;
  bool get avoidReencoding => throw _privateConstructorUsedError;
  String? get videoDynamicRange =>
      throw _privateConstructorUsedError; // 720p, 1080p
  String? get p2pPath => throw _privateConstructorUsedError;
  String? get p2pPathUrlEncoding => throw _privateConstructorUsedError;
  String? get path => throw _privateConstructorUsedError;
  String? get audioCodec => throw _privateConstructorUsedError;
  bool? get audioOnly => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EncodingTrackCopyWith<EncodingTrack> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EncodingTrackCopyWith<$Res> {
  factory $EncodingTrackCopyWith(
          EncodingTrack value, $Res Function(EncodingTrack) then) =
      _$EncodingTrackCopyWithImpl<$Res, EncodingTrack>;
  @useResult
  $Res call(
      {String encodingTrackId,
      String? videoProfile,
      String? audioProfile,
      String? videoCodec,
      int? videoBitRate,
      int audioBitRate,
      String? videoFrameRate,
      int? videoWidth,
      int? videoHeight,
      int audioSamplingRate,
      int audioChannel,
      bool avoidReencoding,
      String? videoDynamicRange,
      String? p2pPath,
      String? p2pPathUrlEncoding,
      String? path,
      String? audioCodec,
      bool? audioOnly});
}

/// @nodoc
class _$EncodingTrackCopyWithImpl<$Res, $Val extends EncodingTrack>
    implements $EncodingTrackCopyWith<$Res> {
  _$EncodingTrackCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? encodingTrackId = null,
    Object? videoProfile = freezed,
    Object? audioProfile = freezed,
    Object? videoCodec = freezed,
    Object? videoBitRate = freezed,
    Object? audioBitRate = null,
    Object? videoFrameRate = freezed,
    Object? videoWidth = freezed,
    Object? videoHeight = freezed,
    Object? audioSamplingRate = null,
    Object? audioChannel = null,
    Object? avoidReencoding = null,
    Object? videoDynamicRange = freezed,
    Object? p2pPath = freezed,
    Object? p2pPathUrlEncoding = freezed,
    Object? path = freezed,
    Object? audioCodec = freezed,
    Object? audioOnly = freezed,
  }) {
    return _then(_value.copyWith(
      encodingTrackId: null == encodingTrackId
          ? _value.encodingTrackId
          : encodingTrackId // ignore: cast_nullable_to_non_nullable
              as String,
      videoProfile: freezed == videoProfile
          ? _value.videoProfile
          : videoProfile // ignore: cast_nullable_to_non_nullable
              as String?,
      audioProfile: freezed == audioProfile
          ? _value.audioProfile
          : audioProfile // ignore: cast_nullable_to_non_nullable
              as String?,
      videoCodec: freezed == videoCodec
          ? _value.videoCodec
          : videoCodec // ignore: cast_nullable_to_non_nullable
              as String?,
      videoBitRate: freezed == videoBitRate
          ? _value.videoBitRate
          : videoBitRate // ignore: cast_nullable_to_non_nullable
              as int?,
      audioBitRate: null == audioBitRate
          ? _value.audioBitRate
          : audioBitRate // ignore: cast_nullable_to_non_nullable
              as int,
      videoFrameRate: freezed == videoFrameRate
          ? _value.videoFrameRate
          : videoFrameRate // ignore: cast_nullable_to_non_nullable
              as String?,
      videoWidth: freezed == videoWidth
          ? _value.videoWidth
          : videoWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      videoHeight: freezed == videoHeight
          ? _value.videoHeight
          : videoHeight // ignore: cast_nullable_to_non_nullable
              as int?,
      audioSamplingRate: null == audioSamplingRate
          ? _value.audioSamplingRate
          : audioSamplingRate // ignore: cast_nullable_to_non_nullable
              as int,
      audioChannel: null == audioChannel
          ? _value.audioChannel
          : audioChannel // ignore: cast_nullable_to_non_nullable
              as int,
      avoidReencoding: null == avoidReencoding
          ? _value.avoidReencoding
          : avoidReencoding // ignore: cast_nullable_to_non_nullable
              as bool,
      videoDynamicRange: freezed == videoDynamicRange
          ? _value.videoDynamicRange
          : videoDynamicRange // ignore: cast_nullable_to_non_nullable
              as String?,
      p2pPath: freezed == p2pPath
          ? _value.p2pPath
          : p2pPath // ignore: cast_nullable_to_non_nullable
              as String?,
      p2pPathUrlEncoding: freezed == p2pPathUrlEncoding
          ? _value.p2pPathUrlEncoding
          : p2pPathUrlEncoding // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      audioCodec: freezed == audioCodec
          ? _value.audioCodec
          : audioCodec // ignore: cast_nullable_to_non_nullable
              as String?,
      audioOnly: freezed == audioOnly
          ? _value.audioOnly
          : audioOnly // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EncodingTrackImplCopyWith<$Res>
    implements $EncodingTrackCopyWith<$Res> {
  factory _$$EncodingTrackImplCopyWith(
          _$EncodingTrackImpl value, $Res Function(_$EncodingTrackImpl) then) =
      __$$EncodingTrackImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String encodingTrackId,
      String? videoProfile,
      String? audioProfile,
      String? videoCodec,
      int? videoBitRate,
      int audioBitRate,
      String? videoFrameRate,
      int? videoWidth,
      int? videoHeight,
      int audioSamplingRate,
      int audioChannel,
      bool avoidReencoding,
      String? videoDynamicRange,
      String? p2pPath,
      String? p2pPathUrlEncoding,
      String? path,
      String? audioCodec,
      bool? audioOnly});
}

/// @nodoc
class __$$EncodingTrackImplCopyWithImpl<$Res>
    extends _$EncodingTrackCopyWithImpl<$Res, _$EncodingTrackImpl>
    implements _$$EncodingTrackImplCopyWith<$Res> {
  __$$EncodingTrackImplCopyWithImpl(
      _$EncodingTrackImpl _value, $Res Function(_$EncodingTrackImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? encodingTrackId = null,
    Object? videoProfile = freezed,
    Object? audioProfile = freezed,
    Object? videoCodec = freezed,
    Object? videoBitRate = freezed,
    Object? audioBitRate = null,
    Object? videoFrameRate = freezed,
    Object? videoWidth = freezed,
    Object? videoHeight = freezed,
    Object? audioSamplingRate = null,
    Object? audioChannel = null,
    Object? avoidReencoding = null,
    Object? videoDynamicRange = freezed,
    Object? p2pPath = freezed,
    Object? p2pPathUrlEncoding = freezed,
    Object? path = freezed,
    Object? audioCodec = freezed,
    Object? audioOnly = freezed,
  }) {
    return _then(_$EncodingTrackImpl(
      encodingTrackId: null == encodingTrackId
          ? _value.encodingTrackId
          : encodingTrackId // ignore: cast_nullable_to_non_nullable
              as String,
      videoProfile: freezed == videoProfile
          ? _value.videoProfile
          : videoProfile // ignore: cast_nullable_to_non_nullable
              as String?,
      audioProfile: freezed == audioProfile
          ? _value.audioProfile
          : audioProfile // ignore: cast_nullable_to_non_nullable
              as String?,
      videoCodec: freezed == videoCodec
          ? _value.videoCodec
          : videoCodec // ignore: cast_nullable_to_non_nullable
              as String?,
      videoBitRate: freezed == videoBitRate
          ? _value.videoBitRate
          : videoBitRate // ignore: cast_nullable_to_non_nullable
              as int?,
      audioBitRate: null == audioBitRate
          ? _value.audioBitRate
          : audioBitRate // ignore: cast_nullable_to_non_nullable
              as int,
      videoFrameRate: freezed == videoFrameRate
          ? _value.videoFrameRate
          : videoFrameRate // ignore: cast_nullable_to_non_nullable
              as String?,
      videoWidth: freezed == videoWidth
          ? _value.videoWidth
          : videoWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      videoHeight: freezed == videoHeight
          ? _value.videoHeight
          : videoHeight // ignore: cast_nullable_to_non_nullable
              as int?,
      audioSamplingRate: null == audioSamplingRate
          ? _value.audioSamplingRate
          : audioSamplingRate // ignore: cast_nullable_to_non_nullable
              as int,
      audioChannel: null == audioChannel
          ? _value.audioChannel
          : audioChannel // ignore: cast_nullable_to_non_nullable
              as int,
      avoidReencoding: null == avoidReencoding
          ? _value.avoidReencoding
          : avoidReencoding // ignore: cast_nullable_to_non_nullable
              as bool,
      videoDynamicRange: freezed == videoDynamicRange
          ? _value.videoDynamicRange
          : videoDynamicRange // ignore: cast_nullable_to_non_nullable
              as String?,
      p2pPath: freezed == p2pPath
          ? _value.p2pPath
          : p2pPath // ignore: cast_nullable_to_non_nullable
              as String?,
      p2pPathUrlEncoding: freezed == p2pPathUrlEncoding
          ? _value.p2pPathUrlEncoding
          : p2pPathUrlEncoding // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      audioCodec: freezed == audioCodec
          ? _value.audioCodec
          : audioCodec // ignore: cast_nullable_to_non_nullable
              as String?,
      audioOnly: freezed == audioOnly
          ? _value.audioOnly
          : audioOnly // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EncodingTrackImpl implements _EncodingTrack {
  const _$EncodingTrackImpl(
      {required this.encodingTrackId,
      required this.videoProfile,
      required this.audioProfile,
      required this.videoCodec,
      required this.videoBitRate,
      required this.audioBitRate,
      required this.videoFrameRate,
      required this.videoWidth,
      required this.videoHeight,
      required this.audioSamplingRate,
      required this.audioChannel,
      required this.avoidReencoding,
      required this.videoDynamicRange,
      required this.p2pPath,
      required this.p2pPathUrlEncoding,
      required this.path,
      required this.audioCodec,
      required this.audioOnly});

  factory _$EncodingTrackImpl.fromJson(Map<String, dynamic> json) =>
      _$$EncodingTrackImplFromJson(json);

  @override
  final String encodingTrackId;
  @override
  final String? videoProfile;
  @override
  final String? audioProfile;
  @override
  final String? videoCodec;
  @override
  final int? videoBitRate;
  @override
  final int audioBitRate;
  @override
  final String? videoFrameRate;
  @override
  final int? videoWidth;
  @override
  final int? videoHeight;
  @override
  final int audioSamplingRate;
  @override
  final int audioChannel;
  @override
  final bool avoidReencoding;
  @override
  final String? videoDynamicRange;
// 720p, 1080p
  @override
  final String? p2pPath;
  @override
  final String? p2pPathUrlEncoding;
  @override
  final String? path;
  @override
  final String? audioCodec;
  @override
  final bool? audioOnly;

  @override
  String toString() {
    return 'EncodingTrack(encodingTrackId: $encodingTrackId, videoProfile: $videoProfile, audioProfile: $audioProfile, videoCodec: $videoCodec, videoBitRate: $videoBitRate, audioBitRate: $audioBitRate, videoFrameRate: $videoFrameRate, videoWidth: $videoWidth, videoHeight: $videoHeight, audioSamplingRate: $audioSamplingRate, audioChannel: $audioChannel, avoidReencoding: $avoidReencoding, videoDynamicRange: $videoDynamicRange, p2pPath: $p2pPath, p2pPathUrlEncoding: $p2pPathUrlEncoding, path: $path, audioCodec: $audioCodec, audioOnly: $audioOnly)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EncodingTrackImpl &&
            (identical(other.encodingTrackId, encodingTrackId) ||
                other.encodingTrackId == encodingTrackId) &&
            (identical(other.videoProfile, videoProfile) ||
                other.videoProfile == videoProfile) &&
            (identical(other.audioProfile, audioProfile) ||
                other.audioProfile == audioProfile) &&
            (identical(other.videoCodec, videoCodec) ||
                other.videoCodec == videoCodec) &&
            (identical(other.videoBitRate, videoBitRate) ||
                other.videoBitRate == videoBitRate) &&
            (identical(other.audioBitRate, audioBitRate) ||
                other.audioBitRate == audioBitRate) &&
            (identical(other.videoFrameRate, videoFrameRate) ||
                other.videoFrameRate == videoFrameRate) &&
            (identical(other.videoWidth, videoWidth) ||
                other.videoWidth == videoWidth) &&
            (identical(other.videoHeight, videoHeight) ||
                other.videoHeight == videoHeight) &&
            (identical(other.audioSamplingRate, audioSamplingRate) ||
                other.audioSamplingRate == audioSamplingRate) &&
            (identical(other.audioChannel, audioChannel) ||
                other.audioChannel == audioChannel) &&
            (identical(other.avoidReencoding, avoidReencoding) ||
                other.avoidReencoding == avoidReencoding) &&
            (identical(other.videoDynamicRange, videoDynamicRange) ||
                other.videoDynamicRange == videoDynamicRange) &&
            (identical(other.p2pPath, p2pPath) || other.p2pPath == p2pPath) &&
            (identical(other.p2pPathUrlEncoding, p2pPathUrlEncoding) ||
                other.p2pPathUrlEncoding == p2pPathUrlEncoding) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.audioCodec, audioCodec) ||
                other.audioCodec == audioCodec) &&
            (identical(other.audioOnly, audioOnly) ||
                other.audioOnly == audioOnly));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      encodingTrackId,
      videoProfile,
      audioProfile,
      videoCodec,
      videoBitRate,
      audioBitRate,
      videoFrameRate,
      videoWidth,
      videoHeight,
      audioSamplingRate,
      audioChannel,
      avoidReencoding,
      videoDynamicRange,
      p2pPath,
      p2pPathUrlEncoding,
      path,
      audioCodec,
      audioOnly);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EncodingTrackImplCopyWith<_$EncodingTrackImpl> get copyWith =>
      __$$EncodingTrackImplCopyWithImpl<_$EncodingTrackImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EncodingTrackImplToJson(
      this,
    );
  }
}

abstract class _EncodingTrack implements EncodingTrack {
  const factory _EncodingTrack(
      {required final String encodingTrackId,
      required final String? videoProfile,
      required final String? audioProfile,
      required final String? videoCodec,
      required final int? videoBitRate,
      required final int audioBitRate,
      required final String? videoFrameRate,
      required final int? videoWidth,
      required final int? videoHeight,
      required final int audioSamplingRate,
      required final int audioChannel,
      required final bool avoidReencoding,
      required final String? videoDynamicRange,
      required final String? p2pPath,
      required final String? p2pPathUrlEncoding,
      required final String? path,
      required final String? audioCodec,
      required final bool? audioOnly}) = _$EncodingTrackImpl;

  factory _EncodingTrack.fromJson(Map<String, dynamic> json) =
      _$EncodingTrackImpl.fromJson;

  @override
  String get encodingTrackId;
  @override
  String? get videoProfile;
  @override
  String? get audioProfile;
  @override
  String? get videoCodec;
  @override
  int? get videoBitRate;
  @override
  int get audioBitRate;
  @override
  String? get videoFrameRate;
  @override
  int? get videoWidth;
  @override
  int? get videoHeight;
  @override
  int get audioSamplingRate;
  @override
  int get audioChannel;
  @override
  bool get avoidReencoding;
  @override
  String? get videoDynamicRange;
  @override // 720p, 1080p
  String? get p2pPath;
  @override
  String? get p2pPathUrlEncoding;
  @override
  String? get path;
  @override
  String? get audioCodec;
  @override
  bool? get audioOnly;
  @override
  @JsonKey(ignore: true)
  _$$EncodingTrackImplCopyWith<_$EncodingTrackImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Thumbnail _$ThumbnailFromJson(Map<String, dynamic> json) {
  return _Thumbnail.fromJson(json);
}

/// @nodoc
mixin _$Thumbnail {
  String get snapshotThumbnailTemplate => throw _privateConstructorUsedError;
  List<String> get types => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ThumbnailCopyWith<Thumbnail> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThumbnailCopyWith<$Res> {
  factory $ThumbnailCopyWith(Thumbnail value, $Res Function(Thumbnail) then) =
      _$ThumbnailCopyWithImpl<$Res, Thumbnail>;
  @useResult
  $Res call({String snapshotThumbnailTemplate, List<String> types});
}

/// @nodoc
class _$ThumbnailCopyWithImpl<$Res, $Val extends Thumbnail>
    implements $ThumbnailCopyWith<$Res> {
  _$ThumbnailCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? snapshotThumbnailTemplate = null,
    Object? types = null,
  }) {
    return _then(_value.copyWith(
      snapshotThumbnailTemplate: null == snapshotThumbnailTemplate
          ? _value.snapshotThumbnailTemplate
          : snapshotThumbnailTemplate // ignore: cast_nullable_to_non_nullable
              as String,
      types: null == types
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ThumbnailImplCopyWith<$Res>
    implements $ThumbnailCopyWith<$Res> {
  factory _$$ThumbnailImplCopyWith(
          _$ThumbnailImpl value, $Res Function(_$ThumbnailImpl) then) =
      __$$ThumbnailImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String snapshotThumbnailTemplate, List<String> types});
}

/// @nodoc
class __$$ThumbnailImplCopyWithImpl<$Res>
    extends _$ThumbnailCopyWithImpl<$Res, _$ThumbnailImpl>
    implements _$$ThumbnailImplCopyWith<$Res> {
  __$$ThumbnailImplCopyWithImpl(
      _$ThumbnailImpl _value, $Res Function(_$ThumbnailImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? snapshotThumbnailTemplate = null,
    Object? types = null,
  }) {
    return _then(_$ThumbnailImpl(
      snapshotThumbnailTemplate: null == snapshotThumbnailTemplate
          ? _value.snapshotThumbnailTemplate
          : snapshotThumbnailTemplate // ignore: cast_nullable_to_non_nullable
              as String,
      types: null == types
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThumbnailImpl implements _Thumbnail {
  const _$ThumbnailImpl(
      {required this.snapshotThumbnailTemplate,
      required final List<String> types})
      : _types = types;

  factory _$ThumbnailImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThumbnailImplFromJson(json);

  @override
  final String snapshotThumbnailTemplate;
  final List<String> _types;
  @override
  List<String> get types {
    if (_types is EqualUnmodifiableListView) return _types;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  @override
  String toString() {
    return 'Thumbnail(snapshotThumbnailTemplate: $snapshotThumbnailTemplate, types: $types)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThumbnailImpl &&
            (identical(other.snapshotThumbnailTemplate,
                    snapshotThumbnailTemplate) ||
                other.snapshotThumbnailTemplate == snapshotThumbnailTemplate) &&
            const DeepCollectionEquality().equals(other._types, _types));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, snapshotThumbnailTemplate,
      const DeepCollectionEquality().hash(_types));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ThumbnailImplCopyWith<_$ThumbnailImpl> get copyWith =>
      __$$ThumbnailImplCopyWithImpl<_$ThumbnailImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ThumbnailImplToJson(
      this,
    );
  }
}

abstract class _Thumbnail implements Thumbnail {
  const factory _Thumbnail(
      {required final String snapshotThumbnailTemplate,
      required final List<String> types}) = _$ThumbnailImpl;

  factory _Thumbnail.fromJson(Map<String, dynamic> json) =
      _$ThumbnailImpl.fromJson;

  @override
  String get snapshotThumbnailTemplate;
  @override
  List<String> get types;
  @override
  @JsonKey(ignore: true)
  _$$ThumbnailImplCopyWith<_$ThumbnailImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
